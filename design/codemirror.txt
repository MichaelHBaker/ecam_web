# CodeMirror Integration Specification for ECAM Web Application

This specification outlines a modular approach to integrate CodeMirror into your ECAM web application, starting with text file support while providing a foundation for future expansion to other data sources (database, API).

## 1. Overall Architecture

### 1.1 Module Structure

We'll create a modular system with these components:

1. **Core Module (`codemirror.js`)**: Base functionality, manages loading and instances
2. **Text/CSV Module (`codemirror-data.js`)**: Specialized for text file viewing/editing
3. **Integration Interface**: Methods for the rest of your application to use

### 1.2 Design Principles

- **Separation of concerns**: Each module has a single responsibility
- **Lazy loading**: Resources load only when needed
- **Consistent state management**: Following your existing state patterns
- **Extensibility**: Clear paths for adding database and API support later
- **Error handling**: Comprehensive error capture and reporting

## 2. Core Module Specification (`codemirror.js`)

### 2.1 Responsibilities

- Load CodeMirror library and dependencies
- Create and manage editor instances
- Handle basic editor configuration
- Provide lifecycle management

### 2.2 API

```javascript
// Main initialization
initialize(): Promise<CodeMirrorManager>

// Check initialization status
isInitialized(): boolean

// Load CodeMirror libraries (called automatically as needed)
load(): Promise<boolean>

// Create instance
create(elementId, options): Promise<{instance, instanceId}>

// Get instance
getInstance(instanceId): Object

// Destroy instance
destroy(instanceId): Promise<boolean>

// Clean up all instances
cleanupAll(): Promise<void>
```

### 2.3 State Management

Uses a dedicated state key: `'codemirror_state'`

Structure:
```javascript
{
  instances: {
    [instanceId]: {
      targetId: string,
      mode: string,
      readOnly: boolean,
      lastUpdate: Date
    }
  },
  loaded: boolean,
  error: {
    context: string,
    message: string,
    stack: string,
    timestamp: Date
  },
  lastUpdate: Date
}
```

## 3. Text/CSV Module Specification (`codemirror-data.js`)

### 3.1 Responsibilities

- Detect file type and structure 
- Enhanced CSV viewing with headers and data detection
- Create specialized data viewers
- Provide data parsing utilities

### 3.2 API

```javascript
// Initialize
initialize(): Promise<CodeMirrorDataManager>

// Create data viewer with specialized features
createDataViewer(elementId, content, options): Promise<{
  instance,
  instanceId,
  contentType,
  parseData: Function
}>

// Parse viewer content 
parseViewerContent(instanceId, contentType): Promise<Object>

// CSV-specific utilities
analyzeCSV(content, options): Promise<Object>
parseCSV(content, options): Promise<Object>
```

### 3.3 State Management

Uses a dedicated state key: `'codemirror_data_state'`

Structure:
```javascript
{
  dataViews: {
    [instanceId]: {
      contentType: string,
      options: Object,
      structure: {
        headerRow: number,
        dataStartRow: number,
        columns: Array
      },
      lastUpdate: Date
    }
  },
  lastUpdate: Date
}
```

## 4. Extension Points for Future Modules

### 4.1 Database Module (Placeholder)

```javascript
// Future database module API outline
initialize(): Promise<CodeMirrorDatabaseManager>
createQueryEditor(elementId, dbType, initialQuery, options): Promise<Object>
executeQuery(instanceId, callback): Promise<string>
formatQuery(instanceId): Promise<void>
```

### 4.2 API Module (Placeholder)

```javascript
// Future API module API outline
initialize(): Promise<CodeMirrorApiManager>
createApiEditor(elementId, contentType, initialContent, options): Promise<Object>
prettifyContent(instanceId): Promise<void>
validateContent(instanceId): Promise<Object>
```

## 5. Implementation Plan

### 5.1 Phase 1: Core Module

1. Create base `codemirror.js` with initialization and loading
2. Implement instance management
3. Add error handling and state management
4. Create tests for core functionality

### 5.2 Phase 2: Text/CSV Module

1. Create `codemirror-data.js` building on core
2. Implement CSV detection and analysis
3. Add CSV parsing with PapaParse integration
4. Create specialized UI for data files

### 5.3 Phase 3: Integration

1. Modify ImportManager to use the new modules
2. Update CRUD operations to work with CodeMirror
3. Create user documentation for the integration

## 6. Detail Requirements for Implementation

### 6.1 Core Module Requirements

- **Library Loading**: Load CodeMirror from CDN with proper error handling
- **Options Management**: Support all needed CodeMirror options
- **Instance Tracking**: Reliable way to track and clean up instances
- **Error Recovery**: Provide fallbacks if CodeMirror fails to load

### 6.2 Text/CSV Module Requirements

- **Content Type Detection**: Identify file type from content
- **CSV Structure Analysis**: Detect headers, delimiters, and data types
- **Line Marking**: Mark header rows, data start points
- **Data Extraction**: Convert viewed data to usable format

### 6.3 Integration Requirements

- **Import Flow**: Seamless integration with file import process
- **Preview Mode**: Support read-only preview with annotations
- **Edit Mode**: Support data editing with validation
- **Data Processing**: Extract structured data for backend processing

## 7. Integration Example with ImportManager

The following example shows how the ImportManager would use the new modules:

```javascript
// In ImportManager.showPreview method:
async showPreview(content) {
  // Create container for editor
  const editorContainer = DOM.createElement('div', {
    id: `preview-editor-${this.locationId}`
  });
  container.appendChild(editorContainer);

  // Create data viewer with CodeMirrorData module
  const { instance, instanceId, contentType } = 
    await CodeMirrorData.createDataViewer(
      `preview-editor-${this.locationId}`,
      content,
      { readOnly: true }
    );

  // Store for cleanup
  this.editorInstanceId = instanceId;

  // Update state
  this.updateState({
    preview: {
      content,
      contentType,
      instanceId,
      timestamp: new Date()
    }
  });

  // Analyze content
  await this.analyzePreviewContent(content, contentType);
}

// In ImportManager.destroy method:
async destroy() {
  // Clean up CodeMirror instance
  if (this.editorInstanceId) {
    await CodeMirror.destroy(this.editorInstanceId);
  }
  
  // Other cleanup...
}
```

## 8. Implementation Details: Core Module

### 8.1 Core Module Implementation (`codemirror.js`)

```javascript
// codemirror.js
// Enhanced CodeMirror management with proper initialization and safety checks

import { State } from './state.js';
import { DOM } from './dom.js';
import { NotificationUI } from './ui.js';

const CODEMIRROR_STATE_KEY = 'codemirror_state';

/**
 * Enhanced CodeMirror Manager with initialization safety and dependency checks
 */
class CodeMirrorManager {
    constructor() {
        this.initialized = false;
        this.instances = new Map();
        this.loaded = false;
        this.loadPromise = null;
    }

    /**
     * Check if CodeMirror manager is initialized
     * @returns {boolean}
     */
    isInitialized() {
        return this.initialized;
    }

    /**
     * Initialize CodeMirror manager with dependency checks
     * @returns {Promise<CodeMirrorManager>} Initialized instance
     */
    async initialize() {
        if (this.initialized) {
            console.warn('CodeMirrorManager already initialized');
            return this;
        }

        try {
            // Check dependencies
            if (!State.isInitialized()) {
                throw new Error('State must be initialized before CodeMirrorManager');
            }
            if (!DOM.isInitialized()) {
                throw new Error('DOM must be initialized before CodeMirrorManager');
            }

            // Initialize state
            State.set(CODEMIRROR_STATE_KEY, {
                instances: {},
                loaded: false,
                error: null,
                lastUpdate: new Date()
            });

            this.initialized = true;
            console.log('CodeMirrorManager initialized');

            return this;
        } catch (error) {
            this.handleError('Initialization Error', error);
            throw error;
        }
    }

    /**
     * Load CodeMirror library and dependencies
     * @returns {Promise<boolean>} Success status
     */
    async load() {
        this._checkInitialized();

        if (this.loaded) return true;
        if (this.loadPromise) return this.loadPromise;

        this.loadPromise = new Promise(async (resolve, reject) => {
            try {
                // Check if already loaded
                if (window.CodeMirror) {
                    this.loaded = true;
                    this.updateState({ loaded: true });
                    resolve(true);
                    return;
                }

                // Load main script
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js');
                
                // Load CSS
                await this.loadStylesheet('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css');
                await this.loadStylesheet('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/default.min.css');
                
                // Load additional modes as needed
                await Promise.all([
                    this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js'),
                    this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js'),
                    this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js')
                ]);

                this.loaded = true;
                this.updateState({ loaded: true });
                resolve(true);
            } catch (error) {
                this.handleError('Library Loading Error', error);
                reject(error);
            }
        });

        return this.loadPromise;
    }

    /**
     * Create a new CodeMirror instance
     * @param {string} elementId - Target element ID
     * @param {Object} options - Editor options
     * @returns {Promise<Object>} CodeMirror instance
     */
    async create(elementId, options = {}) {
        this._checkInitialized();

        const instanceId = `cm-${elementId}-${Date.now()}`;
        
        try {
            // Ensure CodeMirror is loaded
            await this.load();

            // Get target element
            const element = DOM.getElement(elementId);
            if (!element) {
                throw new Error(`Target element not found: ${elementId}`);
            }

            // Set default options
            const defaultOptions = {
                mode: 'text/plain',
                theme: 'default',
                lineNumbers: true,
                readOnly: false,
                viewportMargin: Infinity,
                lineWrapping: false,
                scrollbarStyle: 'native',
                fixedGutter: true,
                gutters: ["CodeMirror-linenumbers", "CodeMirror-linedata"],
                extraKeys: {
                    "Ctrl-F": "findPersistent",
                    "Cmd-F": "findPersistent"
                }
            };

            // Create instance
            const cmInstance = CodeMirror.fromTextArea(element, {
                ...defaultOptions,
                ...options
            });

            // Store instance
            this.instances.set(instanceId, {
                id: instanceId,
                targetId: elementId,
                instance: cmInstance,
                options: { ...defaultOptions, ...options },
                marks: new Map(),
                state: {
                    content: cmInstance.getValue(),
                    selections: [],
                    scrollInfo: cmInstance.getScrollInfo(),
                    lastUpdate: new Date()
                }
            });

            // Update state
            this.updateState({
                instances: {
                    ...this.getState().instances,
                    [instanceId]: {
                        targetId: elementId,
                        mode: options.mode || defaultOptions.mode,
                        readOnly: options.readOnly || defaultOptions.readOnly,
                        lastUpdate: new Date()
                    }
                }
            });

            // Register instance cleanup
            this.setupInstanceCleanup(instanceId, cmInstance);

            return {
                instance: cmInstance,
                instanceId
            };

        } catch (error) {
            this.handleError('Instance Creation Error', error);
            throw error;
        }
    }

    /**
     * Add markers to CodeMirror instance
     * @param {string} instanceId - CodeMirror instance ID
     * @param {Array} markers - Marker configurations
     * @returns {Promise<Array>} Created markers
     */
    async addMarkers(instanceId, markers) {
        this._checkInitialized();

        const stored = this.instances.get(instanceId);
        if (!stored) {
            throw new Error(`CodeMirror instance not found: ${instanceId}`);
        }

        const cmInstance = stored.instance;
        const createdMarkers = [];

        try {
            for (const marker of markers) {
                const markerElement = this.createMarkerElement(marker);
                
                const createdMarker = cmInstance.setGutterMarker(
                    marker.line,
                    marker.gutter || "CodeMirror-linedata",
                    markerElement
                );

                stored.marks.set(marker.id || `marker-${Date.now()}-${marker.line}`, {
                    element: markerElement,
                    config: marker,
                    instance: createdMarker
                });

                createdMarkers.push(createdMarker);
            }

            return createdMarkers;

        } catch (error) {
            this.handleError('Add Markers Error', error);
            throw error;
        }
    }

    /**
     * Create marker element
     * @private
     */
    createMarkerElement(config) {
        const marker = document.createElement('div');
        marker.className = `marker-${config.type}`;
        
        if (config.icon) {
            marker.innerHTML = `<i class="bi bi-${config.icon}"></i> ${config.text || config.type}`;
        } else {
            marker.textContent = config.text || config.type;
        }

        if (config.style) {
            Object.assign(marker.style, config.style);
        }

        return marker;
    }

    /**
     * Get CodeMirror instance by ID
     * @param {string} instanceId - Instance ID
     * @returns {Object|null} CodeMirror instance or null
     */
    getInstance(instanceId) {
        this._checkInitialized();
        return this.instances.get(instanceId)?.instance || null;
    }

    /**
     * Destroy CodeMirror instance and clean up resources
     * @param {string} instanceId - Instance ID
     * @returns {Promise<boolean>} Success status
     */
    async destroy(instanceId) {
        this._checkInitialized();

        const stored = this.instances.get(instanceId);
        if (!stored) return false;

        try {
            // Clean up instance
            stored.instance.toTextArea();
            
            // Remove from collections
            this.instances.delete(instanceId);

            // Update state
            const currentState = this.getState();
            delete currentState.instances[instanceId];
            
            this.updateState({
                instances: currentState.instances
            });

            return true;

        } catch (error) {
            this.handleError('Instance Destruction Error', error);
            return false;
        }
    }

    /**
     * Get current state
     * @returns {Object} Current state
     * @private
     */
    getState() {
        return State.get(CODEMIRROR_STATE_KEY) || {
            instances: {},
            loaded: false,
            lastUpdate: new Date()
        };
    }

    /**
     * Update state
     * @param {Object} update - State update
     * @private
     */
    updateState(update) {
        State.update(CODEMIRROR_STATE_KEY, {
            ...update,
            lastUpdate: new Date()
        });
    }

    /**
     * Handle errors
     * @private
     */
    handleError(context, error) {
        console.error(`CodeMirror Error (${context}):`, error);
        
        NotificationUI.show({
            message: `CodeMirror Error: ${error.message}`,
            type: 'error',
            duration: 5000
        });

        this.updateState({
            error: {
                context,
                message: error.message,
                stack: error.stack,
                timestamp: new Date()
            }
        });
    }

    /**
     * Load script asynchronously
     * @private
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.async = true;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    /**
     * Load stylesheet asynchronously
     * @private
     */
    loadStylesheet(href) {
        return new Promise((resolve, reject) => {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = href;
            link.onload = resolve;
            link.onerror = reject;
            document.head.appendChild(link);
        });
    }

    /**
     * Setup instance cleanup
     * @private
     */
    setupInstanceCleanup(instanceId, cmInstance) {
        // Add event listener to clean up when editor is destroyed
        const cleanup = () => {
            this.destroy(instanceId);
        };

        // Attach to containing element if possible
        const wrapper = cmInstance.getWrapperElement();
        if (wrapper && wrapper.parentElement) {
            const container = wrapper.parentElement;
            
            // Use MutationObserver to detect when editor is removed from DOM
            const observer = new MutationObserver(mutations => {
                for (const mutation of mutations) {
                    for (const node of mutation.removedNodes) {
                        if (node === wrapper || node.contains(wrapper)) {
                            cleanup();
                            observer.disconnect();
                            return;
                        }
                    }
                }
            });
            
            observer.observe(container, { childList: true });
        }
    }

    /**
     * Ensure manager is initialized
     * @private
     */
    _checkInitialized() {
        if (!this.initialized) {
            throw new Error('CodeMirror Manager must be initialized before use');
        }
    }

    /**
     * Cleanup all instances and resources
     */
    async cleanupAll() {
        if (!this.initialized) return;

        try {
            // Clean up all instances
            for (const [instanceId] of this.instances) {
                await this.destroy(instanceId);
            }

            // Reset state
            this.instances.clear();
            this.loaded = false;
            this.loadPromise = null;

            State.update(CODEMIRROR_STATE_KEY, {
                instances: {},
                loaded: false,
                error: null,
                lastUpdate: new Date()
            });

        } catch (error) {
            this.handleError('Cleanup Error', error);
        }
    }
}

// Export singleton instance
export const CodeMirror = new CodeMirrorManager();
```

## 9. Implementation Details: Data Module

### 9.1 Text/CSV Module Implementation (`codemirror-data.js`)

```javascript
// codemirror-data.js
// Extended CodeMirror functionality for data files and analysis

import { CodeMirror } from './codemirror.js';
import { State } from './state.js';
import { NotificationUI } from './ui.js';

const DATA_EXTENSIONS_STATE_KEY = 'codemirror_data_state';

/**
 * CodeMirror Data Extensions Manager
 */
class CodeMirrorDataManager {
    constructor() {
        this.initialized = false;
        this.dataTypes = {
            csv: { mode: 'text/plain', delimiter: ',' },
            json: { mode: 'application/json' },
            xml: { mode: 'application/xml' }
        };
    }

    /**
     * Initialize data extensions
     */
    async initialize() {
        if (this.initialized) return this;
        
        try {
            // Ensure base CodeMirror is initialized
            if (!CodeMirror.isInitialized()) {
                await CodeMirror.initialize();
            }
            
            // Initialize state
            State.set(DATA_EXTENSIONS_STATE_KEY, {
                dataViews: {},
                lastUpdate: new Date()
            });
            
            this.initialized = true;
            console.log('CodeMirror Data Extensions initialized');
            
            return this;
        } catch (error) {
            console.error('CodeMirror Data Extensions initialization failed:', error);
            throw error;
        }
    }

    /**
     * Create data viewer for CSV/data files
     * @param {string} elementId - Target element ID
     * @param {string} content - File content
     * @param {Object} options - Viewer options
     * @returns {Promise<Object>} Viewer instance
     */
    async createDataViewer(elementId, content, options = {}) {
        if (!this.initialized) {
            throw new Error('CodeMirror Data Extensions must be initialized before use');
        }
        
        try {
            // Detect content type if not specified
            const contentType = options.contentType || this.detectContentType(content);
            
            // Create base CodeMirror instance with appropriate mode
            const typeConfig = this.dataTypes[contentType] || this.dataTypes.csv;
            
            const editorOptions = {
                mode: typeConfig.mode,
                lineNumbers: true,
                readOnly: options.readOnly !== false,
                viewportMargin: Infinity,
                lineWrapping: options.lineWrapping !== false,
                gutters: [
                    "CodeMirror-linenumbers", 
                    "CodeMirror-linedata",
                    "CodeMirror-linemarkers"
                ]
            };
            
            const { instance, instanceId } = await CodeMirror.create(elementId, editorOptions);
            
            // Set content
            instance.setValue(content);
            
            // Setup data-specific enhancements
            if (contentType === 'csv') {
                await this.enhanceCsvViewer(instance, instanceId, content, options);
            }
            
            // Update state
            State.update(DATA_EXTENSIONS_STATE_KEY, {
                dataViews: {
                    ...State.get(DATA_EXTENSIONS_STATE_KEY).dataViews,
                    [instanceId]: {
                        contentType,
                        options: { ...options },
                        lastUpdate: new Date()
                    }
                }
            });
            
            return {
                instance,
                instanceId,
                contentType,
                parseData: () => this.parseViewerContent(instanceId, contentType)
            };
            
        } catch (error) {
            console.error('Data viewer creation error:', error);
            NotificationUI.show({
                message: `Error creating data viewer: ${error.message}`,
                type: 'error'
            });
            throw error;
        }
    }
    
    /**
     * Enhance CSV viewer with special features
     * @private
     */
    async enhanceCsvViewer(instance, instanceId, content, options) {
        // Parse CSV and analyze structure
        const structure = await this.analyzeCSV(content, options);
        
        // Add header markers
        if (structure.headerRow !== null) {
            await CodeMirror.addMarkers(instanceId, [{
                id: 'header-marker',
                line: structure.headerRow,
                type: 'header',
                text: 'Header',
                icon: 'tag',
                style: { color: '#4CAF50' }
            }]);
        }
        
        // Add data start marker
        if (structure.dataStartRow !== null) {
            await CodeMirror.addMarkers(instanceId, [{
                id: 'data-start-marker',
                line: structure.dataStartRow,
                type: 'data-start',
                text: 'Data Start',
                icon: 'arrow-right-circle',
                style: { color: '#2196F3' }
            }]);
        }
        
        // Setup column click handlers
        instance.on('gutterClick', (cm, lineNum) => {
            this.handleLineClick(instanceId, lineNum);
        });
    }
    
    /**
     * Handle line click in data viewer
     * @private
     */
    async handleLineClick(instanceId, lineNum) {
        // Implementation for line click handling
        console.log(`Line ${lineNum} clicked in instance ${instanceId}`);
        // This would be expanded to handle data definition operations
    }

    /**
     * Detect content type from content
     * @private
     */
    detectContentType(content) {
        const trimmed = content.trimStart();
        
        if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
            return 'json';
        }
        
        if (trimmed.startsWith('<?xml') || trimmed.startsWith('<')) {
            return 'xml';
        }
        
        // Check if CSV
        const lines = trimmed.split('\n', 3);
        if (lines.length > 1) {
            const firstLine = lines[0];
            const commaCount = (firstLine.match(/,/g) || []).length;
            const tabCount = (firstLine.match(/\t/g) || []).length;
            
            if (commaCount > 0 || tabCount > 0) {
                return 'csv';
            }
        }
        
        return 'csv'; // Default to CSV
    }
    
    /**
     * Analyze CSV structure
     * @private
     */
    async analyzeCSV(content, options = {}) {
        const lines = content.split('\n');
        const structure = {
            totalLines: lines.length,
            headerRow: null,
            dataStartRow: null,
            delimiter: options.delimiter || ',',
            columns: []
        };
        
        // Detect header row and columns
        for (let i = 0; i < Math.min(10, lines.length); i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const fields = line.split(structure.delimiter);
            
            // Check if this looks like a header row
            const isHeader = this.isLikelyHeaderRow(fields);
            if (isHeader && structure.headerRow === null) {
                structure.headerRow = i;
                structure.columns = fields.map(f => ({
                    name: f.trim(),
                    type: null
                }));
                continue;
            }
            
            // If we found a non-header row with data, mark it as data start
            if (structure.dataStartRow === null && 
                fields.length > 1 && 
                fields.some(f => this.isNumeric(f.trim()))) {
                structure.dataStartRow = i;
                
                // If we didn't find a header, use this to define columns
                if (structure.headerRow === null) {
                    structure.columns = fields.map((_, i) => ({
                        name: `Column ${i+1}`,
                        type: null
                    }));
                }
                
                // Detect column types from this first data row
                this.detectColumnTypes(structure, fields);
                break;
            }
        }
        
        return structure;
    }
    
    /**
     * Check if array of values is likely a header row
     * @private
     */
    isLikelyHeaderRow(fields) {
        if (fields.length < 2) return false;
        
        // Check if all fields are text (non-numeric)
        return fields.every(f => {
            const trimmed = f.trim();
            return trimmed && !this.isNumeric(trimmed);
        });
    }
    
    /**
     * Check if string is numeric
     * @private
     */
    isNumeric(str) {
        return !isNaN(str) && !isNaN(parseFloat(str));
    }
    
    /**
     * Detect column types from data row
     * @private
     */
    detectColumnTypes(structure, fields) {
        fields.forEach((value, i) => {
            if (i >= structure.columns.length) return;
            
            const column = structure.columns[i];
            const trimmed = value.trim();
            
            if (!trimmed) return;
            
            if (this.isNumeric(trimmed)) {
                column.type = trimmed.includes('.') ? 'float' : 'integer';
            } else if (/^\d{4}-\d{2}-\d{2}/.test(trimmed)) {
                column.type = 'date';
            } else if (/^\d{2}:\d{2}(:\d{2})?/.test(trimmed)) {
                column.type = 'time';
            } else {
                column.type = 'string';
            }
        });
    }
    
    /**
     * Parse current content in viewer
     * @param {string} instanceId - Instance ID
     * @param {string} contentType - Content type 
     * @returns {Promise<Object>} Parsed data
     */
    async parseViewerContent(instanceId, contentType) {
        const instance = CodeMirror.getInstance(instanceId);
        if (!instance) {
            throw new Error(`CodeMirror instance not found: ${instanceId}`);
        }
        
        const content = instance.getValue();
        
        try {
            switch(contentType) {
                case 'json':
                    return JSON.parse(content);
                case 'csv':
                    return this.parseCSV(content);
                case 'xml':
                    const parser = new DOMParser();
                    return parser.parseFromString(content, 'text/xml');
                default:
                    return content;
            }
        } catch (error) {
            console.error('Content parsing error:', error);
            throw new Error(`Failed to parse ${contentType}: ${error.message}`);
        }
    }
    
    /**
     * Parse CSV content
     * @private
     */
    parseCSV(content, options = {}) {
        return new Promise((resolve, reject) => {
            try {
                if (typeof Papa === 'undefined') {
                    // Load Papa Parse if not available
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js';
                    script.onload = () => {
                        this.parseCsvWithPapa(content, options, resolve, reject);
                    };
                    script.onerror = () => reject(new Error('Failed to load CSV